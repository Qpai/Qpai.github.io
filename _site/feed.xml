<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Qpai</title>
    <description>你好，我的名字叫李祎，我是一只码农，目前专注于iOS/客户端架构设计/Hybrid/项目管理</description>
    <link>http://qpai.github.io/</link>
    <atom:link href="http://qpai.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 28 Jun 2015 23:46:05 +0800</pubDate>
    <lastBuildDate>Sun, 28 Jun 2015 23:46:05 +0800</lastBuildDate>
    <generator>Jekyll v2.1.1</generator>
    
      <item>
        <title>各种通信协议及REST、Socket概述总结</title>
        <description>&lt;h2 id=&quot;tcpip&quot;&gt;TCP/IP&lt;/h2&gt;

&lt;p&gt;TCP/IP是一个完整的协议系统，存在一个协议集，其中包含了多个协议，并且对这些协议进行了分层。这些协议定义了数据单元的格式和内容。TCP/IP及其相关协议构成了一套在TCP/IP网络中如何处理、传输和接收数据的完整系统。&lt;/p&gt;

&lt;h3 id=&quot;udptcp&quot;&gt;UDP和TCP协议&lt;/h3&gt;

&lt;p&gt;UDP和TCP是TCP/IP协议分层中，传输层的两个协议。&lt;/p&gt;

&lt;h3 id=&quot;tcp&quot;&gt;TCP(传输控制协议)&lt;/h3&gt;

&lt;p&gt;是一种面向连接，相对可靠稳定的协议，保证了数据正确性。当数据需要传递时，会进行三次握手建立连接，并且在数据传递时，有确认、窗口、重传、拥塞控制机制，数据传完之后还会进行四次握手来断开连接，节约系统资源。&lt;/p&gt;

&lt;p&gt;当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分为适当长度的报文段，最大传输段大小(MSS)通常受该计算机连接的网络数据链路层的最大传送单元(MTU)限制。&lt;/p&gt;

&lt;p&gt;但是因为要建立连接，并且进行多种复杂机制的操作，导致了较慢，占用系统资源比较高。&lt;/p&gt;

&lt;h3 id=&quot;udp&quot;&gt;UDP(用户数据报协议)&lt;/h3&gt;

&lt;p&gt;无连接，也没有确认，窗口，重传，拥塞控制等机制，同时也不提供数据包分组，排序的功能，所以当数据发送出去之后，发送端并不知道数据是否发送成功还是失败。&lt;/p&gt;

&lt;p&gt;UDP的数据包前8个字节是报头，包含了源端口号，目标端口号，数据报长度，校验值。数据报长度是数据长度+报头长度&lt;/p&gt;

&lt;p&gt;由于是无连接的，而且操作机制很少，所以较快，但是数据无序，并且丢包可能性大。如果要进行维护，必须依赖于应用层协议。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;TCP/IP入门景点&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/subview/32754/8048820.htm?fr=aladdin&quot;&gt;TCP(传输控制协议)百度百科&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/view/30509.htm?fr=aladdin&quot;&gt;UDP(用户数据报协议)百度百科&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ctowhy.com/132.html&quot;&gt;TCP和UDP有什么区别，TCP和UDP各有什么优缺点？&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP(超文本传送协议)&lt;/h2&gt;

&lt;p&gt;HTTP是TCP/IP协议组的的一个应用层协议，而且基于TCP协议（上面已经说明白了TCP协议和TCP/IP的关系），其由请求和响应构成，是一个标准的客户端服务端模型。&lt;/p&gt;

&lt;p&gt;HTTP协议是无状态协议，对于事务的处理没有记忆能力，假如后续处理需要前面的信息，它必须重新传输。&lt;/p&gt;

&lt;p&gt;目前使用的HTTP/1.1协议和HTTP1.0及以前版本的区别是：当一个获取一个web页面的时候，以前版本可能需要建立多个TCP连接，而1.1版本只需要建立一个连接，重复使用。&lt;/p&gt;

&lt;p&gt;目前的绝大部分防火墙可以允许HTTP协议请求的通过。&lt;/p&gt;

&lt;p&gt;REST(表述性状态转移)，这是一种架构风格，是一组架构约束条件和原则。如果你的应用满足了这些约束条件和原则，那么你的应用就是RESTful。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个资源都应该定义为URI。&lt;/li&gt;
  &lt;li&gt;将所有事物链接在一起&lt;/li&gt;
  &lt;li&gt;使用标准的HTTP方法来进行操作。&lt;/li&gt;
  &lt;li&gt;资源多重表述(即同一个资源不仅可以表述成XML的形式，也可以表述成Json，只需要在Header中进行配置，就可以读取不同表述的同一个资源)&lt;/li&gt;
  &lt;li&gt;无状态通信&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://kb.cnblogs.com/page/132129/&quot;&gt;深入浅出REST&lt;/a&gt;
&lt;a href=&quot;http://baike.baidu.com/view/1077487.htm?fr=aladdin&quot;&gt;REST百度百科&lt;/a&gt;
&lt;a href=&quot;http://baike.baidu.com/view/1628025.htm&quot;&gt;HTTP百度百科&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;sip&quot;&gt;SIP&lt;/h2&gt;

&lt;p&gt;SIP(会话发起协议)是一种应用层的，基于文本的协议，类似于HTTP协议，使用UDP和TCP协议，还是用了多种其他协议，比如负责语音质量的RSVP(资源预留协议)，负责定为的LDAP(轻型目录访问协议)，负责身份验证的RADIUS(远程身份验证拨入用户服务)，负责实时传输的RTP等多个协议。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/gnuhpc/201201/201201161517218838.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SIP有类似于HTTP的Method，比如INVITE，ASK，CANCEL等。同时也有和HTTP类似的状态码和短语，比如1xx，2xx之类&lt;/p&gt;

&lt;p&gt;定义了用户标识后，我们就可以定义请求的标识了——SIP中称为方法（Method）。其他的扩展方法在后续的RFC中都有定义。&lt;/p&gt;

&lt;p&gt;SIP仅仅是建立和拆除了会话，但是又不定义会话内容类型，究竟是文本，还是语音，还是视频，什么格式的语音，这些信息都需要发起者在INVITE这个命令中带有，这些协议遵守SDP(会话描述协议)&lt;/p&gt;

&lt;p&gt;SDP能提供以下信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;会话名和目的&lt;/li&gt;
  &lt;li&gt;会话激活的时间&lt;/li&gt;
  &lt;li&gt;构成会话的媒体&lt;/li&gt;
  &lt;li&gt;怎么样接收这些媒体（地址，端口号，格式）
及其他：&lt;/li&gt;
  &lt;li&gt;会议使用的带宽&lt;/li&gt;
  &lt;li&gt;负责这个会话的那个人的联系方式
等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SIP消息和具体的媒体流并不是在一个层面运作的。SIP的根本作用是完成点对点(或多点)的媒体流传输的前序工作。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/gnuhpc/archive/2012/01/16/2323637.html&quot;&gt;【SIP协议】学习初学笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhaobl/archive/2011/12/31/2282534.html&quot;&gt;SIP学习之旅【环境搭建篇】&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;xmpp&quot;&gt;XMPP&lt;/h2&gt;

&lt;p&gt;XMPP(可扩展通讯和表示协议)是一种基于XML的、可扩展的、开放的协议，客户端服务器端协议。它目前执行的标准专门应用于即时通信，为即时通信&lt;/p&gt;

&lt;p&gt;因为是基于XML的协议，使其可以进行扩展，增加更多自定义的信息传输的数据中，而这个协议已经被IETF定为标准协议，那么只要是支持XMPP的应用，他们之间就可以互动，使开放成为可能。&lt;/p&gt;

&lt;p&gt;XMPP协议基于TCP协议，通过TCP协议传输XML数据。其也可以通过HTTP连接轮询(估计就是我们现在用的HTTP长连接)方式实现，但是在XMPP的&lt;code&gt;RFC 3920&lt;/code&gt;标准协议文档中只使用TCP。&lt;/p&gt;

&lt;p&gt;XMPP中定义了三个角色，客户端，服务器，网关。通信能够在这三者的任意两个之间双向发生。服务器同时承担了客户端信息记录，连接管理和信息的路由功能。网关承担着与异构即时通信系统的互联互通，异构系统可以包括SMS（短信），MSN，ICQ等。基本的网络形式是单客户端通过TCP/IP连接到单服务器，然后在之上传输XML。&lt;/p&gt;

&lt;p&gt;客户端可以使用一个TCP连接来发送和接收XML数据，但是服务器必须使用两个TCP连接分别发送和接收XML数据。&lt;/p&gt;

  	C: &lt;?xml version=&#39;1.0&#39;?&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;stream:stream to=&#39;example.com&#39; xmlns=&#39;jabber:client&#39; xmlns:stream=&#39;http://etherx.jabber.org/streams&#39; version=&#39;1.0&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

   	S: &lt;?xml version=&#39;1.0&#39;?&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;stream:stream from=&#39;example.com&#39; id=&#39;someid&#39; xmlns=&#39;jabber:client&#39; xmlns:stream=&#39;http://etherx.jabber.org/streams&#39; version=&#39;1.0&#39;&amp;gt;
   	...  encryption, authentication, and resource binding ...
&lt;/code&gt;&lt;/pre&gt;

   	C:   &lt;message from=&quot;juliet@example.com&quot; to=&quot;romeo@example.net&quot; xml:lang=&quot;en&quot;&gt;
&lt;/message&gt;
   	C:     &amp;lt;body&amp;gt;Art thou not Romeo, and a Montague?&amp;lt;/body&amp;gt;

   	C:   &amp;lt;/message&amp;gt;

   	S:   &lt;message from=&quot;romeo@example.net&quot; to=&quot;juliet@example.com&quot; xml:lang=&quot;en&quot;&gt;
&lt;/message&gt;
   	S:     &amp;lt;body&amp;gt;Neither, fair saint, if either thee dislike.&amp;lt;/body&amp;gt;

   	S:   &amp;lt;/message&amp;gt;

   	C: &amp;lt;/stream:stream&amp;gt;

   	S: &amp;lt;/stream:stream&amp;gt;

&lt;p&gt;以上就是一个客户端和服务器端相互发消息的简化例子，无论是c2s，还是s2c都是&lt;stream:stream&gt;&lt;/stream:stream&gt;包着内容，每一个&lt;stream:stream&gt;都是一个TCP连接。&lt;/stream:stream&gt;&lt;/p&gt;

&lt;p&gt;XMPP的问题就在于XMPP协议使用的流量太多了，而且不断被重复转发，在移动IM的环境下有了臃肿的感觉。其大部分结构描述比信息都大，因为数据中为了提供路由效率，增加了现场和敏感信息标识，是数据高效路由至最合适的请求资源。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/view/189676.htm?fr=aladdin&quot;&gt;XMPP百度百科&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.jabbercn.org/RFC3920&quot;&gt;XMPP标准文档，RFC3920&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.v2ex.com/t/131245&quot;&gt;XMPP 协议适合用来做移动 IM 么&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SOAP
RTSP
H323&lt;/p&gt;

&lt;h2 id=&quot;rtprtcp&quot;&gt;RTP/RTCP&lt;/h2&gt;

&lt;h3 id=&quot;rtprtcp-1&quot;&gt;RTP(实时传输协议)和RTCP(实时传输控制协议)。&lt;/h3&gt;

&lt;p&gt;RTP是基于UDP协议的传输层的子协议(也可以认为是应用层协议)，定义了流媒体数据包的格式，而RTCP是RTP的控制协议，一般情况下两个协议一起使用。&lt;/p&gt;

&lt;p&gt;RTP一般用于流媒体传输，一般的应用场景是IP电话，视频会议等，我估计QQ的视频聊天也是基于RTP或者类似协议。因为基于UDP，所以RTP可以应用于单播或者多播网络。&lt;/p&gt;

&lt;p&gt;流媒体的最重要形式就是媒体数据依据相对的时间进行顺序播放，而网络传输来的数据包经常是乱序的。所以RTP定义流媒体数据包中要包含，数据的&lt;code&gt;序列号&lt;/code&gt;和&lt;code&gt;时间标签&lt;/code&gt;，这样接收端就可以依据这些数据来进行重组排序，使流媒体可以以正确的顺序播放。&lt;/p&gt;

&lt;p&gt;而解包和重组排序需要花费时间，所以一般的视频应用就会进行预加载，和播放缓冲.&lt;/p&gt;

&lt;p&gt;RTP只是定义了数据包的结构框架，只是提供了数据包的时间信息和流数据的同步。而传输让UDP负责，而服务质量，流量监控等用RTCP负责。&lt;/p&gt;

&lt;h3 id=&quot;rtp&quot;&gt;RTP会话过程&lt;/h3&gt;

&lt;p&gt;当应用程序建立一个RTP会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。
1)        RTP协议从上层接收流媒体信息码流（如H.263），封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包。
2)        RTP将RTP 数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/bripengandre/article/details/2238818&quot;&gt;RTP协议分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://zhangjunhd.blog.51cto.com/113473/25481/&quot;&gt;RTP与RTCP协议介绍&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;mqtt&quot;&gt;MQTT&lt;/h2&gt;

&lt;p&gt;MQTT（Message Queuing Telemetry Transport，消息队列遥测传输），是IBM推出的一个即时通信协议。是轻量级的、基于代理的发布/订阅的协议。怎么感觉更像苹果的APNS。&lt;/p&gt;

&lt;p&gt;使用TCP/IP系统进行网络请求，但是不确定MQTT在TCP/IP的哪一层。&lt;/p&gt;

&lt;p&gt;相对于XMPP，结构描述信息变得特别小巧，只有两字节，所有消息都存在这两字节的位数据中。不要以为两字节很小，存不了多少数据，其实MQTT最多可以实现256M的数据，可谓能伸能缩。&lt;/p&gt;

&lt;p&gt;而且很适用于移动互联网的网络不稳定的特点，因为MQTT定义了三种发布服务质量：&lt;code&gt;至多一次、至少一次，只有一次&lt;/code&gt;。如果网络环境差，那么至少一次绝对能确保消息到达。网络环境非常好，只有一次就够了。但是不只是发送多次的问题，还有根据不同的选择配合不同的协议进来&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html&quot;&gt;IBMMQTT文档&lt;/a&gt;
&lt;a href=&quot;http://blog.csdn.net/king_of_fighter/article/details/17401133&quot;&gt;MQTT协议详解一&lt;/a&gt;
&lt;a href=&quot;http://blog.csdn.net/king_of_fighter/article/details/17415277&quot;&gt;MQTT协议详解二&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;socket&quot;&gt;Socket&lt;/h2&gt;

&lt;h3 id=&quot;sockettcpip&quot;&gt;Socket在TCP/IP中属于什么位置？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/goodcandle/socket2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;socket-1&quot;&gt;socket简介&lt;/h3&gt;

&lt;p&gt;Socket是应用层和TCP/IP协议族通信的软件抽象层，其设计成了门面模式。它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://jingyan.baidu.com/article/08b6a591e07ecc14a80922f1.html&quot;&gt;TCP/IP、Http、Socket的区别&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://goodcandle.cnblogs.com/archive/2005/12/10/294652.aspx&quot;&gt;揭开Socket编程的面纱&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Oct 2014 20:00:00 +0800</pubDate>
        <link>http://qpai.github.io/2014/10/06/%E5%90%84%E7%A7%8D%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%8F%8Arest%E3%80%81socket%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://qpai.github.io/2014/10/06/%E5%90%84%E7%A7%8D%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%8F%8Arest%E3%80%81socket%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93/</guid>
        
        
      </item>
    
      <item>
        <title>分析Facebook pop</title>
        <description>&lt;h2 id=&quot;facebook-pop&quot;&gt;分析Facebook pop&lt;/h2&gt;

&lt;h3 id=&quot;pop&quot;&gt;pop的优势&lt;/h3&gt;

&lt;p&gt;首先，最重要的一点就是CALayer和presentLayer的属性是一致的，而CoreAnimation是不一致的。&lt;/p&gt;

&lt;p&gt;其次，pop的动画是可中断式的，可中断是什么含义呢？假如CoreAnimation removeAnimation，那么运行动画的对象将回到动画开始的状态，而pop removeAnimation将停止在删除动画时，对象所在的状态，不会回到初始状态。&lt;/p&gt;

&lt;h3 id=&quot;cadisplaylinknstimer&quot;&gt;CADisplayLink和NSTimer的区别&lt;/h3&gt;

&lt;p&gt;CADisplayLink是一个允许你的程序按照屏幕刷新去重绘的同步计时器对象。CADisplayLink提供了一个selector和target对象，屏幕一刷新就会调用selector，必须把CADisplayLink加入run loop。&lt;/p&gt;

&lt;p&gt;屏幕的刷新频率是60HZ，所以CADisplayLink默认一秒刷新60次，当然你可以减少刷新次数，那么某些帧就会被跳过，不去调用selector。&lt;/p&gt;

&lt;p&gt;pop就是使用的CADisplayLink。&lt;/p&gt;

&lt;p&gt;NSTimer同样也是同步的，是runloop的定时源，runloop需要把NSTimer强引用，NSTimer才能启动。NSTimer的精度是50–100毫秒，但是如果错过了下一个时间点也是有可能的，所以并不精确。&lt;/p&gt;

&lt;p&gt;比如设置NSTimer的周期是60s，如果runloop被阻塞了，当判断是不是该调用NSTimer的时候，发现已经61s了，因为可能会碰到阻塞或者其他什么情况，这是runloop就会忽略掉这个时间点。&lt;/p&gt;

&lt;p&gt;CADisplayLink不属于定时源，所以runloop观察到屏幕刷新，就会调用selector，所以CADisplayLink相对精确。&lt;/p&gt;

&lt;h3 id=&quot;pop-1&quot;&gt;pop如何实现可中断动画&lt;/h3&gt;

&lt;p&gt;CADisplayerLink 在pop中的回调函数是在&lt;code&gt;POPAnimator&lt;/code&gt;中的&lt;code&gt;- (void)render&lt;/code&gt;，每次屏幕重绘的时候，就调用了&lt;code&gt;render&lt;/code&gt;，在这个方法里面调用了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)_renderTime:(CFTimeInterval)time items:(std::list&amp;lt;POPAnimatorItemRef&amp;gt;)items
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以修改所有多个需要执行动画的对象，在这个方法中，使用了核心动画事务类&lt;code&gt;CATransaction&lt;/code&gt;，以同时修改多个对象的属性。&lt;/p&gt;

&lt;p&gt;执行单个对象渲染的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)_renderTime:(CFTimeInterval)time item:(POPAnimatorItemRef)item
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个方法里面，调用了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void applyAnimationTime(id obj, POPAnimationState *state, CFTimeInterval time)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;applyAnimationTime&lt;/code&gt;里调用传入的writeblock和readblock进行修改和读取对象frame。&lt;/p&gt;

&lt;p&gt;同时还执行了这段代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!state-&amp;gt;advanceTime(time, obj)) {
	return;
  	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;advanceTime&lt;/code&gt;方法，通过时间，刷新了当前时间应该设置的位置，或者说状态。&lt;/p&gt;

&lt;p&gt;这里使用了&lt;code&gt;CACurrentMediaTime()&lt;/code&gt;以获取相对精确的当前时间，是mach_absolute_time()获取微妙级别的时间，再转化成秒。这个时间每次系统更新都会被重置，如果mac，会是这次开机时间到当前时间的时间差，iPhone可能同理，开机时间和当前时间的时间差。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;advanceTime&lt;/code&gt;内部调用了&lt;code&gt;advance&lt;/code&gt;，这是一个可以被子类重写的方法，不同类型的动画，只需要重写这个方法，加入自己类型动画如何计算下一次刷新的状态逻辑，就可以搞定。&lt;/p&gt;

&lt;h3 id=&quot;popanimatableproperty&quot;&gt;POPAnimatableProperty&lt;/h3&gt;

&lt;p&gt;这是pop的动画属性，即，里面封装了所有可变化的kvc属性，每一个属性的name，writeblock,readblock，临界值都被封装成了一个结构&lt;code&gt;_POPStaticAnimatablePropertyState&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;比如frame的变化，就如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; {kPOPViewFrame,
	^(UIView *obj, CGFloat values[]) {
  	values_from_rect(values, obj.frame);
	},
	^(UIView *obj, const CGFloat values[]) {
  	obj.frame = values_to_rect(values);
	},
	kPOPThresholdPoint
  	},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pop-2&quot;&gt;pop的新增动画类型&lt;/h3&gt;

&lt;h4 id=&quot;popspringanimation-&quot;&gt;PopSpringAnimation 弹簧效果&lt;/h4&gt;

&lt;p&gt;即对象执行这个动画的时候，会有一个晃动的效果，并且会逐渐衰减幅度&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw1024/65cc0af7gw1egqpgva69rg208u0fpjtx.gif&quot; alt=&quot;fds&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;popdecayanimation-&quot;&gt;PopDecayAnimation 衰减动画&lt;/h4&gt;

&lt;p&gt;对象移动过程中，有一个缓慢到达，直到停止的效果，类似于UISrollView的拖动过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/65cc0af7gw1egmzoapnqwg206i0bm7nn.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;自定义动画引擎&lt;/h3&gt;

&lt;p&gt;大家看了这篇文章，是不是有一种貌似很简单的感觉。&lt;/p&gt;

&lt;p&gt;那么我们就梳理一下，pop这样的动画引擎都有那些必要部分&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个AnimationState状态类型，即我们目前支持什么属性动画，各种属性如何变化&lt;/li&gt;
  &lt;li&gt;一个全局动画单例，来接收屏幕刷新事件，并且保存需要执行动画的对象及其参数&lt;/li&gt;
  &lt;li&gt;各种动画类型，比如贝塞尔曲线类型，Spring类型，Decay类型，等，及其他们在时间变化的过程中，各参数进行变化的逻辑 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后，如何组织运行动画？&lt;/p&gt;

&lt;p&gt;CADisplayerLink接收屏幕刷新-》判断是否有需要执行动画的对象-》判断是什么动画，参数该根据时间怎么变？-》给对象设置新的状态&lt;/p&gt;

&lt;p&gt;好吧，一个动画的一帧就结束了。&lt;/p&gt;

&lt;p&gt;具体请参考&lt;a href=&quot;https://github.com/cyndibaby905/CHAnimation&quot;&gt;CHAnimation&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/wzzvictory/article/details/22417181&quot;&gt;Core Animation系列之CADisplayLink&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/pop&quot;&gt;Facebook pop&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rnystrom/PopDemos&quot;&gt;RayWenderlich pop Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://geeklu.com/2014/05/facebook-pop-usage/&quot;&gt;facebook pop 使用指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/cyndibaby905/CHAnimation&quot;&gt;CHAnimation&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Sep 2014 20:00:00 +0800</pubDate>
        <link>http://qpai.github.io/2014/09/17/%E5%88%86%E6%9E%90facebook_pop/</link>
        <guid isPermaLink="true">http://qpai.github.io/2014/09/17/%E5%88%86%E6%9E%90facebook_pop/</guid>
        
        
      </item>
    
      <item>
        <title>Debugging in Xcode 6</title>
        <description>&lt;h2 id=&quot;debugging-in-xcode-6&quot;&gt;Debugging in Xcode 6&lt;/h2&gt;

&lt;h2 id=&quot;section&quot;&gt;内容包括&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;更有效的调试GCD&lt;/li&gt;
  &lt;li&gt;浏览你的用户界面&lt;/li&gt;
  &lt;li&gt;集成快速预览到你的类&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;backtraces-&quot;&gt;Backtraces 回溯&lt;/h2&gt;

&lt;p&gt;GCD让人崩溃的回溯记录&lt;/p&gt;

&lt;p&gt;![fd](img/GCDBefore.png “”)&lt;/p&gt;

&lt;p&gt;看到了没有，加入使用GCD异步启动一个任务，等到了断点的时候，只有GCD所在的方法能显示出来&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/GCDNow.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可是现在，完全看到了整个堆栈记录，还知道来自哪个线程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/iconDebug.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这些图标都是什么意思？灰色又是代表什么？&lt;/p&gt;

&lt;p&gt;live的堆栈是彩色的&lt;/p&gt;

&lt;p&gt;记录堆栈帧的图标是灰色的,因为它是一个视觉提示让你知道它已经是历史。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Historical&lt;/li&gt;
  &lt;li&gt;No console interaction 不能在控制台中交互，因为已经不在内存中了&lt;/li&gt;
  &lt;li&gt;No frame variables &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;img/debugControllerBtn.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有一个按钮，叫Process View Option Selector，点击它，我们可以看到三个选项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;按照线程查看进程&lt;/li&gt;
  &lt;li&gt;按照队列查看进程&lt;/li&gt;
  &lt;li&gt;查看UI层级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;点击第二个选项&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/blockQueue.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我写了一个嵌套的block异步执行任务，上面的绿色icon下面的是正在执行的block，下面灰色的是已经执行完的block。&lt;/p&gt;

&lt;p&gt;假如队列中有N个串行任务，断点断到的任务是执行中的任务，而xcode 6也会显示等待中的任务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/sequenceBlock.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以Xcode 6 中会显示等待执行的block&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/serialDebug.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;debug-&quot;&gt;Debug 用户界面&lt;/h2&gt;

&lt;p&gt;还记得我们之前Process View Option Selector按钮下面有一个查看UI层级的选项吗？点一下看看会发生什么？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/UIDebug.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看到了我们Demo的当前界面对吗？每个视图还加上了边。&lt;/p&gt;

&lt;p&gt;而Xcode 6的左边还有层次关系，还能搜索呢，对吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/UIDebugHierarchy.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而左下角的两个小按钮，左边的那个点中之后，显示主要视图，右面那个，可以把所有隐藏的视图显示出来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/3DUIDebug.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看啊，是不是很帅，可以3D看层次，还可以选择某个层次的视图，是不是很方便。之前有&lt;code&gt;http://revealapp.com/&lt;/code&gt;可以做到这件事，不过收费了，而且还需要嵌入SDK，现在有了xcode 6，码农们有福了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/UIDebugToolButton.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来看看这些按钮都是做什么的。&lt;/p&gt;

&lt;p&gt;第一个可拖动的按钮，向左滑，层级之间的间距扩大
第四个是复原位置
第五个是放大缩小视图
第六个是从右向左或者从左向右依次隐藏视图
第二个第三个点了没反应&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;快速预览&lt;/h2&gt;

&lt;p&gt;Xcode 最近一年的更新增加了很多功能，以前预览功能，就是那个小眼睛，能看的东西很少，比如UIImage，现在变得多了很多：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/quickView.png&quot; alt=&quot;fd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而且，我们可以实现自定义View的预览。&lt;/p&gt;

&lt;p&gt;只需要在对象内部实现&lt;code&gt;- (id)debugQuickLookObject&lt;/code&gt;即可&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2014/413xxr7gdc60u2p/413/413_debugging_in_xcode_6.pdf?dl=1&quot;&gt;Debugging in Xcode 6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/toyship/KTest&quot;&gt;debugQuickLookObject示例&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Sep 2014 20:00:00 +0800</pubDate>
        <link>http://qpai.github.io/2014/09/17/debugging_in_xcode_6/</link>
        <guid isPermaLink="true">http://qpai.github.io/2014/09/17/debugging_in_xcode_6/</guid>
        
        
      </item>
    
      <item>
        <title>cocoapods实践记</title>
        <description>&lt;h1 id=&quot;cocoapods&quot;&gt;cocoapods实践记&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;公司有一个主客户端包含了很多频道的业务，若干个频道的app客户端，经常需要频道客户端的代码和主客户端的代码进行相互copy to each other。&lt;/p&gt;

&lt;p&gt;这样的问题在于，代码会被随意更改，不可复用，无法升级，工作量分散，&lt;/p&gt;

&lt;p&gt;所以我主张使用&lt;code&gt;cocoapods&lt;/code&gt;进行组件管理，当然有同学推荐我使用&lt;a href=&quot;http://schacon.github.io/git/user-manual.html#submodules&quot;&gt;git submodule&lt;/a&gt; 进行管理。&lt;/p&gt;

&lt;p&gt;公司这时有了一个新组件:X，主客户端和频道子app客户端都需要用到，我想，这是一个彻底改变项目开发问题的机会。&lt;/p&gt;

&lt;h2 id=&quot;cocoapods-1&quot;&gt;cocoapods介绍&lt;/h2&gt;

&lt;p&gt;其实不用我介绍，大多数iOS开发者都知道cocoapods。&lt;/p&gt;

&lt;p&gt;我们为了避免重复造轮子，经常会使用第三方库，而iOS的项目开发，如果引入第三方库，需要进行很多项目的配置，以前我们只能人肉手动去修改项目文件，现在有了cocoapods，帮助我们以最快的速度将第三方库导入我们项目中，只需一个命令行&lt;code&gt;pod install&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;真假美猴王&lt;/h2&gt;

&lt;p&gt;首先我开始对各个项目进行调研，马上问题出来了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;公司的各个应用中存在相同的第三方库，但是版本不一样。&lt;/li&gt;
  &lt;li&gt;很多第三方库被改动了&lt;/li&gt;
  &lt;li&gt;各个项目中存在相同名称的类，但是功能不一样&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比如Afnetworking，各个项目使用的是不同的版本，而且被改动了。有项目以前用的是老版本，但是后来看到了升级版本，手动加入了一部分升级功能，还不完全。&lt;/p&gt;

&lt;p&gt;经过了一些讨论，我们进行了如下工作，来减少项目代码冲突&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对于相同的第三方库，各个项目进行版本调研，查找出项目的原始版本，和目前项目中使用的版本，有何不同，使用categroy等方式进行抽离，保证第三方库的完整和干净。2. &lt;/li&gt;
  &lt;li&gt;各个项目尽量使用相同版本的第三方库，各个项目同时进行升级&lt;/li&gt;
  &lt;li&gt;同时，各个项目的代码文件，必须添加前缀，避免类名冲突。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cocoapods-2&quot;&gt;cocoapods私有库&lt;/h2&gt;

&lt;p&gt;为了将新项目X使用cocoapods进行集成，我们在内部的git库中建立了私有的specs库&lt;/p&gt;

&lt;p&gt;按照&lt;a href=&quot;http://guides.cocoapods.org/making/private-cocoapods.html&quot;&gt;cocoapods private&lt;/a&gt;教程的介绍，我们进行建立。&lt;/p&gt;

&lt;p&gt;其实github上面的&lt;a href=&quot;https://github.com/CocoaPods/Specs/&quot;&gt;CocoaPods/Specs&lt;/a&gt;是cocoapods的公共配置库，如果想建立自己的私有配置库，只需要在自己的git服务器上面建一个项目，比如叫DemoSpecs。内容呢，就遵循如下路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── Specs
	└── [自定义库名]
    	└── [版本号]
        	└── [自定义库名].podspec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，私有库就建成了，每当我们需要加入一个私有新库的时候，只需要在Specs中增加一个文件夹，命名为&lt;code&gt;自定义库名&lt;/code&gt;，在其中放入不同版本的配置文件即可。&lt;/p&gt;

&lt;p&gt;当然这个时候，使用&lt;code&gt;pod search customPod&lt;/code&gt;还是搜不到东西的，你需要把这个DemoSPecs克隆到本地去。&lt;/p&gt;

&lt;p&gt;打开终端，输入以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod repo add REPO_NAME SOURCE_URL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中REPO_NAME 是你本地的specs库名，这个可以自定义。而SOURCE_URL是DemoSpecs的git地址。&lt;/p&gt;

&lt;p&gt;这时候使用&lt;code&gt;pod search customPod&lt;/code&gt;就能搜到你私有cocoapod的库了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;单体双胞胎&lt;/h2&gt;

&lt;p&gt;我们在开发新组件X的的过程中，使用了以前的老代码，而新组件的这部分老代码使用的是MRC，而新代码使用了ARC，这是复杂呀。那么如何在配置文件中，对这两部分代码进行区分呢？&lt;/p&gt;

&lt;p&gt;podspecs文件中是可以配置&lt;code&gt;subspec&lt;/code&gt;的，我将两部分代码进行了拆分，幸运的时候两部分代码一部分是数据处理，一部分是UI，那么我建立了两个文件夹分别存放这两部分代码，同时在podSpecs中配置了子&lt;code&gt;subspec&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subspec &quot;data&quot; do |sp|
  	sp.source_files = &quot;Classes/data&quot;
  	sp.requires_arc = false
end

subspec &quot;UI&quot; do |sp|
  	sp.source_files = &quot;Classes/UI&quot;
  	sp.requires_arc = true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，集成的时候，就会对两部分代码进行分别配置。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;静态库的处理&lt;/h2&gt;

&lt;p&gt;我们用到了静态库，在开发语音模块的过程中，使用了&lt;code&gt;libopencore-amrnb.a&lt;/code&gt;的静态库，静态库如何集成进项目中呢？&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://guides.cocoapods.org/syntax/podspec.html#vendored_libraries&quot;&gt;vendored_libraries&lt;/a&gt;给了我们答案：&lt;/p&gt;

&lt;p&gt;spec.vendored_libraries = ‘libProj4.a’, ‘libJavaScriptCore.a’&lt;/p&gt;

&lt;p&gt;不过切记，这里写的路径，必须是git的路径，把路径写全了，只写一个.a文件名，可集成不进去。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;为什么我老是集成失败？&lt;/h2&gt;

&lt;p&gt;我们在项目中使用了&lt;code&gt;yajl-json&lt;/code&gt;，发现每次集成的时候都失败了。老是有文件没有集成进去，后来发现，cocoapods允许pod在install之后执行其他命令，而yajl执行了&lt;code&gt;cmake&lt;/code&gt;命令，而我们没有安装&lt;code&gt;cmake&lt;/code&gt;命令行工具，就导致了我们没有集成成功。&lt;/p&gt;

&lt;h2 id=&quot;cocoapods-3&quot;&gt;为什么使用cocoapods集成之后包变大了？&lt;/h2&gt;

&lt;p&gt;我想说其实这是一个伪命题，其实包没有大，只是Cocoapods帮你在项目里面多加了几个armv而已.至少我发现的是这样。&lt;/p&gt;

&lt;h2 id=&quot;tag&quot;&gt;为什么让我每次都重新生成tag？？&lt;/h2&gt;

&lt;p&gt;我们在开发的过程中，直接引用的是git地址+tag方式，结果迭代过程中，每次修改，项目组其他成员集成的之前，都必须重新生成一次tag。我承认我犯二了。。其实cocoapods给了解决方案，那就是直接指向git地址，最终发布release版本后，再生成tag，这样就可以了。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;终于碰到的技术问题都解决了，&lt;code&gt;pod install&lt;/code&gt;之后，新组件X终于集成进了各个项目里面。&lt;/p&gt;

&lt;p&gt;感谢Cocoapods的团队，为我们提供了这么牛的工具!!&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Jul 2014 20:00:00 +0800</pubDate>
        <link>http://qpai.github.io/2014/07/20/cocoapods%E5%AE%9E%E8%B7%B5%E8%AE%B0/</link>
        <guid isPermaLink="true">http://qpai.github.io/2014/07/20/cocoapods%E5%AE%9E%E8%B7%B5%E8%AE%B0/</guid>
        
        
      </item>
    
      <item>
        <title>用runtime生成一个类</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;生成类&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;先判断一下是否已经存在了这个类&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; if (objc_lookUpClass(keyName)) {
     return YES;
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取父类&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Class superClass = objc_getClass(&quot;NSObject&quot;);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;一般来讲，用底层的NSObject类做父类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向内存中添加类&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Class newClass = objc_allocateClassPair(superClass, newClassName, 0);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;给类添加属性&lt;/h3&gt;

&lt;p&gt;有了类，该往类中添加属性了，也就是类的属性，及其存取。&lt;/p&gt;

&lt;p&gt;其实有一种最简单的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class_addMethod(newClass, NSSelectorFromString(@&quot;getName&quot;), imp_implementationWithBlock(^(id obj){
    return objc_getAssociatedObject(obj, &quot;name&quot;);
    
}), &quot;@@:&quot;);

class_addMethod(newClass, NSSelectorFromString(@&quot;setName:&quot;), imp_implementationWithBlock(^(id obj ,NSString *value){

    objc_setAssociatedObject(obj, &quot;name&quot;, value, OBJC_ASSOCIATION_RETAIN);
}), &quot;v@:@&quot;);

[obj1 performSelector:NSSelectorFromString(@&quot;setName:&quot;) withObject:@&quot;HelloName&quot;];
id value = [obj1 performSelector:NSSelectorFromString(@&quot;getName&quot;)];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式使用了AssociatedObject对象，完全和ivar和property无关，AssociatedObject通过设置objc_AssociationPolicy可以实现property的一些功能，包括copy，retain等。&lt;/p&gt;

&lt;p&gt;接下来，我们使用比较麻烦的方法，给类声明ivar和property，及其存取方法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先添加ivar，因为property是和ivar相关联的。我们声明添加一个_title的ivar&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; class_addIvar(newClass, &quot;_title&quot;, sizeof(id), log2(sizeof(id)), &quot;@&quot;);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;class_addIvar&lt;/code&gt;有五个参数分别是:&lt;/p&gt;

&lt;p&gt;需要添加ivar的类，
ivar的变量名，
实例变量类型所占内存的大小，比如是一个NSString *的ivar，应该用sizeof(NSString *)
ivar的最小基准数
ivar类型的类型编码，最好用 @encode(NSString *)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;给类添加property&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; objc_property_attribute_t t = {&quot;T&quot;,&quot;@\&quot;NSString\&quot;&quot;};
 objc_property_attribute_t n = {&quot;N&quot;,&quot;&quot;};
 objc_property_attribute_t r = {&quot;&amp;amp;&quot;,&quot;&quot;};
 objc_property_attribute_t v = {&quot;V&quot;,&quot;_title&quot;};
 objc_property_attribute_t a[] = {t,n,r,v};
 class_addProperty(newClass, &quot;title&quot;, a, 4);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;N，&amp;amp;代表什么，请查寻一下&lt;a href=&quot;https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW1&quot;&gt;Declared Properties 声明属性&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过，objc_property_attribute_t更像是一种声明，告诉属性的使用者有这些特性，但是addProperty的时候，并没有帮你实现，比如retain，比如copy&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;给类的属性添加存取方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;IMP imp_implementationWithBlock(void *block);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过一个block的指针，实现一个IMP，根据苹果文档的注释，这个block一般遵循如下格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;method_return_type ^(id self, self, method_args …)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;method_args …&lt;/code&gt;就是可变参数列表，第一个参数&lt;code&gt;id self&lt;/code&gt;是接收消息的对象，而第二个参数self，其实应该是&lt;code&gt;SEL _cmd&lt;/code&gt;，一个IMP都会有接收消息的对象，和_cmd这两个参数，不过在这个block的声明中可以忽律掉&lt;code&gt;SEL _cmd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.friday.com/bbum/2011/03/17/ios-4-3-imp_implementationwithblock/&quot;&gt;iOS 4.3: imp_implementationWithBlock()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇文章解释了为什么&lt;code&gt;SEL _cmd&lt;/code&gt;不用声明出来（挺长，英文复杂没翻译出来，以后需要在深入研究）&lt;/p&gt;

&lt;p&gt;如果你想实现一个下面方法的IMP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (int)skew:(int)j
{
    return j + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该写成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IMP skewIMP = imp_implementationWithBlock(^(id _s, int k)
    {
        return k + 1;
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，_s就接收消息的对象，而&lt;code&gt;SEL _cmd&lt;/code&gt;被忽略掉了，&lt;code&gt;int k&lt;/code&gt;就是参数了。&lt;/p&gt;

&lt;p&gt;好了，该实现我们自己的存取方法了。这里仅仅进行简单复制，copy，和retain请自行解决。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class_addMethod(newClass, NSSelectorFromString(@&quot;getTitle&quot;), imp_implementationWithBlock(^(id obj){
        Ivar titleVar = class_getInstanceVariable(newClass, &quot;_title&quot;);
        return  object_getIvar(obj, titleVar);
    }), &quot;v@:&quot;);
class_addMethod(newClass, NSSelectorFromString(@&quot;setTitle:&quot;), imp_implementationWithBlock(^(id obj ,NSString *value){
    Ivar titleVar = class_getInstanceVariable(newClass, &quot;_title&quot;);
    object_setIvar(obj, titleVar, value);
}), &quot;v@:@&quot;);
id obj1 = [newClass new];
[obj1 performSelector:@selector(setTitle:) withObject:@&quot;321a&quot;];
NSLog(@&quot;%@&quot;,[obj1 performSelector:@selector(getTitle)]) ;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 11 Jun 2014 20:00:00 +0800</pubDate>
        <link>http://qpai.github.io/2014/06/11/%E7%94%A8runtime%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E7%B1%BB/</link>
        <guid isPermaLink="true">http://qpai.github.io/2014/06/11/%E7%94%A8runtime%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E7%B1%BB/</guid>
        
        
      </item>
    
      <item>
        <title>Cocoapods使用文档</title>
        <description>&lt;h2 id=&quot;cocoapod&quot;&gt;cocoapod使用文档&lt;/h2&gt;

&lt;h1 id=&quot;cocoapod-1&quot;&gt;安装cocoapod&lt;/h1&gt;

&lt;p&gt;首先更新ruby库&lt;/p&gt;

&lt;p&gt;终端中输入下面命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem update --system  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候rubygem的网站会被墙，或者速度很慢，建议换成淘宝的rubygem的库地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem sources --remove https://rubygems.org/
gem sources -a http://ruby.taobao.org/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证是不是已经更换成淘宝地址了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem sources -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果出现&lt;code&gt;http://ruby.taobao.org/&lt;/code&gt;说明正确&lt;/p&gt;

&lt;p&gt;然后执行下面命令安装cocoapod&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install cocoapods
pod setup
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;specs&quot;&gt;克隆公司内部Specs库&lt;/h1&gt;

&lt;h2 id=&quot;specs-1&quot;&gt;克隆公司内部Specs库&lt;/h2&gt;

&lt;p&gt;打开终端，输入以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod repo add REPO_NAME SOURCE_URL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中REPO_NAME 是你本地的specs库名，这个可以自定义。而SOURCE_URL是赶集iOS团队的specs地址。&lt;/p&gt;

&lt;p&gt;执行了上面的命令之后，赶集iOS团队的specs地址就被clone到了你的电脑里。生成本地的specs克隆，你才能找到我们内部的私有项目。&lt;/p&gt;

&lt;h2 id=&quot;specs-2&quot;&gt;更新本地克隆的specs库&lt;/h2&gt;

&lt;p&gt;终端中输入以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod repo update REPO_NAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如我们内部的私有项目进行了版本更新，或者某一个私有项目的podspec配置文件进行了修改，我们就需要更新一下本地specs库。&lt;/p&gt;

&lt;p&gt;假如我们执行&lt;code&gt;pod repo update&lt;/code&gt;其实是进行包括github上面的主公开specs的所有specs本地库的更新。&lt;/p&gt;

&lt;h2 id=&quot;specs-3&quot;&gt;验证本地克隆specs库&lt;/h2&gt;

&lt;p&gt;终端中输入以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod repo lint REPO_NAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候一些项目的podspec语法错误，或者有其他问题，我们用上面的命令就可以进行验证。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;集成内部项目&lt;/h1&gt;

&lt;p&gt;搜索需要的项目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod search afnetwork
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会发现出现了所有带有afnetwork关键词的项目，包括内部的，和github公开库的。&lt;/p&gt;

&lt;p&gt;在项目文件的根目录下，执行下面两行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;touch Podfile  
open -e Podfile 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在打开的一个叫Podfile的文本文件中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod &#39;AFNetworking&#39;, &#39;~&amp;gt; 2.2.4&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存。&lt;/p&gt;

&lt;p&gt;其中pod 是一个命令，AFNetworking 是你要集成的项目，2.2.4是版本号。&lt;/p&gt;

&lt;p&gt;最后执行集成命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会把你之前的项目生成一个workspace，然后将第三方库和你之前的项目集成到一起。大功告成！&lt;/p&gt;

&lt;p&gt;有时候pod install会比较慢，那是因为内部会更新公开specs库。可以使用以下命令加速集成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod install --verbose --no-repo-update 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;verbose 是打开逐步log的参数，而no-repo-update是不更新specs库。&lt;/p&gt;

&lt;h1 id=&quot;podspec&quot;&gt;podspec配置文件&lt;/h1&gt;

&lt;p&gt;如果想让其他项目集成你自己的项目，必须告诉其他项目，你自己项目的配置。podspec就是一个配置文件。&lt;/p&gt;

&lt;p&gt;cocoapod其实是用ruby写的，所以podspec其实就是一个ruby的代码片段。
首先所有配置项被下面的ruby代码包住：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Pod::Spec.new do |s|
    ....
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;含义是Pod命名空间下的Spec类new了一个新的对象，在new的时候需要传一些参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do |s| 
end 其实是new方法传入的一个block，而s就是block的参数，以end结尾。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面会逐个列出常用配置选项。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #项目名称
  s.name         = &quot;xxxProject&quot;
  #版本号
  s.version      = &quot;0.0.1&quot;
  #项目描述
  s.summary      = &quot;xxxProject是一个IM项目&quot;
  #项目首页
  s.homepage     = &quot;http://qpai.github.io&quot;
  #授权协议
  s.license      = &#39;MIT&#39;
  #作者
  s.author       = { &quot;程序员甲&quot; =&amp;gt; &quot;a@126.com&quot; ,&quot;程序员乙&quot; =&amp;gt; &quot;b@126.com&quot;}
  #项目的git地址
  s.source       = { :git =&amp;gt; &quot;xxxProject的git地址&quot;, :tag =&amp;gt; &quot;0.0.1&quot; }
  #项目集成需要的文件
  # s.source_files = &#39;xxxProject/xxxProject/**/*.*&#39;
  #如果将资源打包成bundle，就在这里设置资源文件路径
  #s.resources    = &#39;SIStore/SIStore.bundle&#39;
  #项目使用的framework
  s.framework    = &#39;CoreData&#39; ,&#39;Foundation&#39; ,&#39;CoreGraphics&#39; ,&#39;UIKit&#39;
  #项目使用的非framework系统库
  s.library = &#39;sqlite3&#39;
  #项目使用的第三方静态库，注意，这里必须写git目录的路径
  s.vendored_libraries = &#39;xxxProject/xxxProject/xxxProjectData/util/audio/lib/libopencore-amrnb.a&#39;,&#39;xxxProject/xxxProject/xxxProjectData/util/audio/lib/libopencore-amrwb.a&#39;
  #项目依赖的其他第三方库，必须是公开库或者内部库有的项目，必须填入版本号
  s.dependency &#39;yajl-objc&#39;, &#39;~&amp;gt; 0.2.27&#39;
  s.dependency &#39;AFNetworking&#39;,&#39;~&amp;gt; 1.3.0&#39;
  #项目是否要求arc
  s.requires_arc = true
  #项目平台
  s.platform     = :ios
  #增加的build setting值
  #s.xcconfig  = {&#39;LIBRARY_SEARCH_PATHS&#39; =&amp;gt; &#39;&quot;$(PODS_ROOT)/xxxProject/xxxProject/xxxProject/xxxProjectData/util/audio/lib&quot;&#39;}
  #想加入宿主项目的Prefix header内容
  s.prefix_header_contents = 
    &#39;#import &amp;lt;UIKit/UIKit.h&amp;gt;&#39;
  #可以对部分代码进行个性配置，比如下面两个子subspec,分别定义了非arc文件和arc文件
  s.subspec &quot;xxxProjectUI&quot; do |sp|
    sp.source_files = &quot;xxxProject/xxxProject/xxxProjectUI/**/*.*&quot;
  end
  s.subspec &quot;xxxProjectData&quot; do |sp|
    sp.source_files = &quot;xxxProject/xxxProject/xxxProjectData/**/*.*&quot;
    sp.compiler_flags = &#39;-fno-objc-arc&#39;
    sp.requires_arc = false
    sp.vendored_libraries = &#39;libopencore-amrnb.a&#39;,&#39;libopencore-amrwb.a&#39;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;specs-4&quot;&gt;添加自己的项目到公司内部私有Specs库&lt;/h1&gt;

</description>
        <pubDate>Wed, 11 Jun 2014 20:00:00 +0800</pubDate>
        <link>http://qpai.github.io/2014/06/11/cocoapod%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</link>
        <guid isPermaLink="true">http://qpai.github.io/2014/06/11/cocoapod%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</guid>
        
        
      </item>
    
      <item>
        <title>自动化分发到testflight脚本</title>
        <description>&lt;p&gt;最近公司项目有一些分发的需求，所以我搜索了一些资料，实现了自动打包并且上传到testflight的脚本。&lt;/p&gt;

&lt;p&gt;大概需求有这些&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将版本号和用户名显示在图标上面&lt;/li&gt;
  &lt;li&gt;Archive一个HOC的包&lt;/li&gt;
  &lt;li&gt;本地备份一个ipa和dsym文件&lt;/li&gt;
  &lt;li&gt;上传至Testflight&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;一、图标显示版本号&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装两个shell工具&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; brew install imagemagick  
 brew install ghostscript
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在Build Phases，新建一个Run Script。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;    #这里可以讲版本号设置成SVN或者git的版本号，以防冲突  #/usr/libexec/PlistBuddy -c &quot;Set :CFBundleVersion ${SVN_REVISION}&quot;&quot;$INFO_PLIST_PATH&quot;  version=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;${INFOPLIST_FILE}&quot;`
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;function processIcon() {
     export PATH=$PATH:/usr/local/bin
     base_file=$1
     base_path=&lt;code&gt;find &quot;${SRCROOT}/&amp;lt;project name&amp;gt;&quot; -name $base_file&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; echo &quot;Processing 43 $base_path&quot;
    
 if [[ ! -f ${base_path} || -z ${base_path} ]]; then
 return;
 fi
    
 echo &quot; 11 ${target_path}&quot;
    
 target_file=$base_file
 target_path=&quot;${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/${target_file}&quot;
    
    
    
 if [ $CONFIGURATION = &quot;Release&quot; ]; then
 cp &quot;${base_path}&quot; &quot;$target_path&quot;
 return
 fi
    
 width=`identify -format %w &quot;${base_path}&quot;`
    
 convert -background &#39;#0008&#39; -fill white -gravity center -size ${width}x40\
 caption:&quot;${version} ${LOGNAME}&quot;\
 &quot;${base_path}&quot; +swap -gravity south -composite &quot;${target_path}&quot;
    
 echo &quot;Overlayed ${target_path}&quot;  }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;processIcon “Icon_base.png”
 processIcon “Icon_base@2x.png”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;这里只涉及到了Icon.png和Icon@2x.png的图标，还可以增加更多。  &lt;/li&gt;
  &lt;li&gt;处理了release的配置，如果发布状态，则不显示版本号，可以根据需求修改。  &lt;/li&gt;
  &lt;li&gt;脚本编辑框下面有一个选项：Show environment variables in build   log。如果勾上，那你的log就会出现一堆本地的环境变量及其值，你可以打印出来，写脚本的时候就知道哪些是可以用的环境变量。但是如果调试shell脚本的时候最好不勾上，因为很多，而log最多显示200行，你shell的log可能会被隐藏掉，影响你的调试。  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二、自动打包和上传。&lt;/h2&gt;
&lt;p&gt;在xcode左上角找到edit schame，然后找到左边有Archive，点击旁边的三角，在post-actions增加一个run script。因为需要archive之后，才能找到相应的xcarchive文件，所以是后置运行脚本。&lt;/p&gt;

&lt;p&gt;shell脚本如下：
    #!/bin/sh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#  Script.sh
#  IconOverlaying
#
#  Created by Li Yi on 14-3-9.
#  Copyright (c) 2014年 pixle. All rights reserved.


# define vars
TESTFLIGHT_TEAM_TOKEN=&quot;&amp;lt;team token&amp;gt;&quot;
TESTFLIGHT_API_TOKEN=&quot;&amp;lt;user token&amp;gt;&quot;
TESTFLIGHT_DISTRIBUTION_LIST=&quot;QpaiTeam&quot;
BACK_UP_PATH=&quot;${SOURCE_ROOT}/IpaBackup&quot;



echo &quot;find last Archives&quot;
newest=
backIFS=$IFS
IFS=$(echo -en &#39;\n\b&#39;)
for f in `find ~/Library/Developer/Xcode/Archives -name *.xcarchive`
do
if [ -z $newest ]
then
newest=$f
elif [ $f -nt $newest ]
then
newest=$f
fi
done
echo &quot;${f}&quot;
FS=$backIFS

LASTARCHIVE_PATH=$f

# it&#39;s build version,or git version or svn version
VERSION=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;${INFOPLIST_FILE}&quot;`

IPA_PATH=&quot;${BACK_UP_PATH}/${VERSION}.ipa&quot;
DSYM_PATH=&quot;${LASTARCHIVE_PATH}/dSYMs/${PROJECT_NAME}.app.dSYM&quot;
COPY_DSYM_PATH=&quot;${BACK_UP_PATH}/${VERSION}.app.dSYM&quot;

# create backup folder
mkdir -p &quot;${BACK_UP_PATH}&quot;

rm &quot;${IPA_PATH}&quot;

echo &quot;create ipa from archive&quot;

xcodebuild -exportArchive -exportFormat IPA -archivePath &quot;${LASTARCHIVE_PATH}&quot; -exportPath &quot;${IPA_PATH}&quot;

echo &quot;copy dsym to back-up&quot;
cp -r &quot;${DSYM_PATH}&quot; &quot;${COPY_DSYM_PATH}&quot;


#zipping the .dSYM to send to Testflight
echo &quot;Generating dsym zip file&quot;
/usr/bin/zip -r &quot;${COPY_DSYM_PATH}.zip&quot;&quot;${COPY_DSYM_PATH}&quot;

# sends the .ipa file to TestFlight




echo &quot;Sending to TestFlight&quot;
curl http://testflightapp.com/api/builds.json -F file=&quot;@${IPA_PATH}&quot; \
-F dsym=&quot;@${COPY_DSYM_PATH}.zip&quot; \
-F api_token=&quot;${TESTFLIGHT_API_TOKEN}&quot; \
-F team_token=&quot;${TESTFLIGHT_TEAM_TOKEN}&quot; \
-F notes=&quot;This build was uploaded via the upload API&quot; \
-F notify=False \
-F distribution_lists=&quot;${TESTFLIGHT_DISTRIBUTION_LIST}&quot;
echo Submission ended
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;执行了如下功能：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;寻找最后一个archive&lt;/li&gt;
  &lt;li&gt;生成一个本地备份的文件夹&lt;/li&gt;
  &lt;li&gt;通过最后一个archive生成一个以build版本号命名的ipa，并且保存于备份文件夹中。&lt;/li&gt;
  &lt;li&gt;把最后一个archive的dsym文件复制到备份文件中，并且重命名为版本号。&lt;/li&gt;
  &lt;li&gt;把dsym文件打包成zip&lt;/li&gt;
  &lt;li&gt;通过curl将ipa和dysm上传到testflight&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解释一些需要设置的变量名含义：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;TESTFLIGHT_TEAM_TOKEN就是你Testflight里面team的token&lt;/li&gt;
  &lt;li&gt;TESTFLIGHT_API_TOKEN是你用户的token&lt;/li&gt;
  &lt;li&gt;TESTFLIGHT_DISTRIBUTION_LIST是你的包分发的目标受众，可以是team名，也可以是用户名，用逗号隔开。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意： 最下面的curl就是上传到testflight的接口，和传参。具体是不是上传正确了，需要看log。&lt;/p&gt;
</description>
        <pubDate>Sun, 09 Mar 2014 20:00:00 +0800</pubDate>
        <link>http://qpai.github.io/2014/03/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E5%8F%91%E5%88%B0testflight%E8%84%9A%E6%9C%AC/</link>
        <guid isPermaLink="true">http://qpai.github.io/2014/03/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E5%8F%91%E5%88%B0testflight%E8%84%9A%E6%9C%AC/</guid>
        
        
      </item>
    
      <item>
        <title>Dyci动态注入实践</title>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout:     post
title:      “DyCI动态注入实践”
subtitle:   “如何使用DyCI”
date:       2014-03-03 12:00:00
author:     “Qpai”
header-img: “img/cd-background-img.jpg”
—&lt;/p&gt;

&lt;p&gt;昨天晚上看到了infoQ的iOS周报，发现了一个非常酷的动态注入库&lt;a href=&quot;https://github.com/DyCI/dyci-main&quot;&gt;DyCi&lt;/a&gt;，他可以做到动态的把代码注入到已经运行的程序中。&lt;/p&gt;

&lt;p&gt;可能有些同学还是不太明白具体有什么用，我给大家解释一下：&lt;/p&gt;

&lt;p&gt;可以在开发的过程中，修改UI代码，而不用重新编译就可以在模拟器上面看到修改后的效果。&lt;/p&gt;

&lt;p&gt;是不是很酷，让你瞬间想到了当年在xcode上面用代码写UI，而改一个数值就必须运行一遍看一下效果的黑暗日子？对，天亮了，你可以避免苦难了。&lt;/p&gt;

&lt;p&gt;这篇文章虽然叫实践，其实目前只是对Dyci文档的摘抄，和我简单尝试，以后随着实践的深入还会陆续加入新的内容。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;安装步骤&lt;/h2&gt;

&lt;p&gt;首先看一下安装步骤(&lt;a href=&quot;https://github.com/DyCI/dyci-main/wiki/Installation&quot;&gt;官方安装介绍&lt;/a&gt;)，因为Dyci需要在xcode上面安装一个插件，所以需要你运行一个sh的脚本。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载脚本&lt;/li&gt;
  &lt;li&gt;cd 到脚本目录&lt;/li&gt;
  &lt;li&gt;运行脚本&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;git clone https://github.com/DyCI/dyci-main.git&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;cd dyci-main/Install/&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;/install.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果出现下面的提示，证明你安装成功了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;== Backing up clang : Done.
== Faking up clang : Done.
== Preparing dyci-recompile : Done.
== Copying scripts : Done.
== AppCode found. Installing DYCI as AppCode external tool : Done.
== Installing Xcode DCI plugin : Done.
Now you can use DCI from the Xcode :P (^X)

DCI was successfully installed!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重启Xcode，因为涉及到插件，必须重启在能看到，重启之后，会在xcode的菜单product中看到recompile and inject项，还有快捷键^X。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;引入工程&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;最简单的办法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用cocoapod，在Podfile中加入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod &#39;dyci&#39;, :git =&amp;gt; &#39;https://github.com/DyCI/dyci-main.git&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;作为自项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将dyci项目加入到你工程项目的workspace中，并且在工程项目的Build Phase的Link Binary With Libraries中加入对dyci的依赖：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.github.com/DyCI/dyci.github.com/master/img/dyci-adding-as-static-library.png&quot; alt=&quot;https://raw.github.com/DyCI/dyci.github.com/master/img/dyci-adding-as-static-library.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;作为静态库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下载dyci.framework从&lt;a href=&quot;https://github.com/DyCI/dyci-main/downloads&quot;&gt;这里&lt;/a&gt; &lt;br /&gt;
加入静态库到你的项目中 &lt;br /&gt;
在other link flag中加入-Objc&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;碰到的问题&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;xib可以动态变动，但是代码不行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我新建了一个单页面项目，在里面加入了一个label，^x，可以动态呈现。可是我在VC中的viewDidLoad给self.view加入label，却不能动态呈现，找了半天最后发现了&lt;a href=&quot;https://github.com/DyCI/dyci-main/wiki/Update-on-Injection&quot;&gt;答案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;dyci的wiki是这么说的，代码注入有时候不允许你改变当前已经生成的实例，因为你的VC已经通过initWithNibName生成了实例，所以viewDidLoad加入的代码都不能动态更新。这时就需要你在你想要注入的类中实现&lt;code&gt;-(void)updateOnClassInjection&lt;/code&gt;，这个方法会在你要对当前类或者其子类的实例进行注入的时候调用，下面是例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
   [super viewDidLoad];
   [self createGUI];

}

- (void)updateOnClassInjection {
   // &quot;Emulating&quot; viewDidLoad method  
   // Cleaning up all views and  
   NSArray * subviews = [[self view] subviews];
   for (UIView * v in subviews) {
      [v removeFromSuperview];
   }
   [self createGUI];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个wiki里面，也涉及到了资源的注入，需要实现另外一个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)updateOnResourceInjection:(NSString *)resourcePath
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 03 Mar 2014 00:00:00 +0800</pubDate>
        <link>http://qpai.github.io/2014/03/03/DyCI%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5%E5%AE%9E%E8%B7%B5/</link>
        <guid isPermaLink="true">http://qpai.github.io/2014/03/03/DyCI%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5%E5%AE%9E%E8%B7%B5/</guid>
        
        
      </item>
    
      <item>
        <title>Hello world</title>
        <description>&lt;p&gt;我的博客建好了！&lt;/p&gt;

&lt;p&gt;以前见建过很多博客，几乎都荒废了。这次我希望能坚持下来！&lt;/p&gt;

&lt;p&gt;在我的博客中，我希望，多分享一些翻译的文章，尽量抽时间写一些自己写的技术文章，能给广大开发人员做一些贡献。&lt;/p&gt;

&lt;p&gt;而我自己是移动开发，目前主攻iOS，所以，技术文章主要是iOS相关的。&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Feb 2014 20:00:00 +0800</pubDate>
        <link>http://qpai.github.io/2014/02/26/hello-world/</link>
        <guid isPermaLink="true">http://qpai.github.io/2014/02/26/hello-world/</guid>
        
        
      </item>
    
  </channel>
</rss>
